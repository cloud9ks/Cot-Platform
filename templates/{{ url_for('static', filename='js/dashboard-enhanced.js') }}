// dashboard-enhanced.js - VERSIONE COMPLETA CON TUTTE LE FUNZIONI
// Salva questo file in: static/js/dashboard-enhanced.js

class COTDashboard {
    constructor() {
        this.currentSymbol = 'GOLD';
        this.charts = {};
        this.updateInterval = null;
        this.cache = new Map();
        this.cacheTimeout = 60000; // 1 minuto
        this.isLoading = false;
        this.debounceTimer = null;
        this.debounceDelay = 300;
        
        // Flag per controllo inizializzazione
        this.initialized = false;
        
        this.init();
    }
    
    async init() {
        console.log('üöÄ Inizializzazione COT Dashboard...');
        
        try {
            // Carica i simboli PRIMA di tutto
            await this.loadSymbols();
            
            // Setup event listeners
            this.setupEventListeners();
            
            // Inizializza grafici Chart.js
            await this.initializeCharts();
            
            // Carica dati iniziali
            await this.loadInitialData();
            
            // Auto-refresh ogni 30 secondi
            this.startAutoRefresh(30000);
            
            this.initialized = true;
            console.log('‚úÖ Dashboard inizializzata con successo');
            
        } catch (error) {
            console.error('‚ùå Errore inizializzazione dashboard:', error);
            this.showError('Errore inizializzazione dashboard. Ricarica la pagina.');
        }
    }
    
    async loadSymbols() {
        try {
            const response = await fetch('/api/symbols');
            if (!response.ok) throw new Error('Errore caricamento simboli');
            
            const data = await response.json();
            const container = document.getElementById('symbolSelector');
            
            if (!container) {
                console.error('Container simboli non trovato');
                return;
            }
            
            container.innerHTML = '';
            
            // Mostra messaggio se ci sono limitazioni
            if (data.limit && data.message) {
                const alert = document.createElement('div');
                alert.className = 'alert alert-warning mb-3';
                alert.innerHTML = `<i class="fas fa-info-circle"></i> ${data.message}`;
                container.parentElement.insertBefore(alert, container);
            }
            
            // Crea i pulsanti per i simboli
            data.symbols.forEach((symbol, index) => {
                const btn = document.createElement('button');
                btn.className = 'symbol-btn';
                btn.textContent = symbol.name || symbol.code;
                btn.dataset.symbol = symbol.code;
                
                if (index === 0) {
                    btn.classList.add('active');
                    this.currentSymbol = symbol.code;
                }
                
                btn.addEventListener('click', () => {
                    this.switchSymbol(symbol.code);
                });
                
                container.appendChild(btn);
            });
            
            console.log(`‚úÖ Caricati ${data.symbols.length} simboli`);
            
        } catch (error) {
            console.error('‚ùå Errore caricamento simboli:', error);
            document.getElementById('symbolSelector').innerHTML = 
                '<div class="alert alert-danger">Errore caricamento simboli</div>';
        }
    }
    
    setupEventListeners() {
        // Tab navigation con Bootstrap
        const triggerTabList = document.querySelectorAll('#mainTabs button[data-bs-toggle="tab"]');
        triggerTabList.forEach(triggerEl => {
            triggerEl.addEventListener('shown.bs.tab', (e) => {
                const tabId = e.target.getAttribute('data-bs-target');
                console.log(`üìë Tab attivata: ${tabId}`);
                
                // Carica dati specifici per tab se necessario
                if (tabId === '#technical') {
                    this.loadTechnicalData();
                } else if (tabId === '#economic') {
                    this.loadEconomicData();
                } else if (tabId === '#predictions') {
                    this.loadPredictionsData();
                }
            });
        });
        
        // Refresh button (solo admin)
        const refreshBtn = document.getElementById('btnRefresh');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                this.forceRefresh();
            });
        }
        
        // Analisi AI button (solo admin)
        const runBtn = document.getElementById('btnRun');
        if (runBtn) {
            runBtn.addEventListener('click', async () => {
                await this.runFullAnalysis();
            });
        }
    }
    
    async loadInitialData() {
        if (this.isLoading) {
            console.log('‚è≥ Caricamento gi√† in corso, skip...');
            return;
        }
        
        this.isLoading = true;
        this.showLoader();
        
        try {
            // Carica dati in parallelo
            const [completeData, cotData, economicData] = await Promise.allSettled([
                this.fetchWithCache(`/api/analysis/complete/${this.currentSymbol}`),
                this.fetchWithCache(`/api/data/${this.currentSymbol}?days=90`),
                this.fetchWithCache('/api/economic/current')
            ]);
            
            // Processa analisi completa
            if (completeData.status === 'fulfilled' && completeData.value) {
                this.updateDashboard(completeData.value);
                
                // Aggiorna grafici se ci sono dati tecnici
                if (completeData.value.technical_analysis) {
                    this.updateTechnicalCharts(completeData.value.technical_analysis);
                }
            }
            
            // Processa dati COT
            if (cotData.status === 'fulfilled' && cotData.value) {
                this.updateCOTChart(cotData.value);
                this.updateCOTTable(cotData.value);
            }
            
            // Processa dati economici
            if (economicData.status === 'fulfilled' && economicData.value) {
                this.updateEconomicIndicators(economicData.value);
                this.updateMarketOverview(economicData.value);
            }
            
        } catch (error) {
            console.error('‚ùå Errore caricamento dati:', error);
            this.showError('Errore nel caricamento dei dati');
        } finally {
            this.isLoading = false;
            this.hideLoader();
        }
    }
    
    async fetchWithCache(url) {
        const cacheKey = url;
        const cached = this.cache.get(cacheKey);
        
        // Check cache
        if (cached && (Date.now() - cached.timestamp < this.cacheTimeout)) {
            console.log(`‚úÖ Cache hit: ${url}`);
            return cached.data;
        }
        
        // Fetch con timeout e gestione errori
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
        
        try {
            const response = await fetch(url, {
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            // Salva in cache solo se dati validi
            if (data && !data.error) {
                this.cache.set(cacheKey, {
                    data: data,
                    timestamp: Date.now()
                });
            }
            
            return data;
            
        } catch (error) {
            if (error.name === 'AbortError') {
                console.error(`‚è±Ô∏è Timeout per ${url}`);
            } else {
                console.error(`‚ùå Errore fetch ${url}:`, error);
            }
            
            // Ritorna dati cached anche se vecchi
            if (cached) {
                console.log(`‚ö†Ô∏è Usando cache stale per ${url}`);
                return cached.data;
            }
            
            throw error;
        }
    }
    
    updateDashboard(data) {
        if (!data) return;
        
        console.log('üìä Aggiornamento dashboard con:', data);
        
        // Aggiorna COT data - NOTA GLI ID CORRETTI!
        if (data.cot_data || data.latest_cot) {
            const cotData = data.cot_data || data.latest_cot;
            
            // Net Position
            this.updateElement('netPosition', this.formatNumber(cotData.net_position));
            
            // Net Change
            if (cotData.net_change !== undefined) {
                const changeEl = document.getElementById('netChange');
                if (changeEl) {
                    const changeValue = cotData.net_change || 0;
                    changeEl.textContent = `${changeValue >= 0 ? '+' : ''}${this.formatNumber(changeValue)}`;
                    changeEl.className = changeValue >= 0 ? 'text-success fw-bold' : 'text-danger fw-bold';
                }
            }
            
            // Sentiment Score
            this.updateElement('sentimentScore', `${cotData.sentiment_score?.toFixed(1)}%`);
            
            // Sentiment Bar
            this.updateSentimentBar(cotData.sentiment_score);
            
            // Last Update
            if (cotData.date) {
                const date = new Date(cotData.date);
                this.updateElement('lastUpdate', date.toLocaleDateString('it-IT'));
            }
        }
        
        // Aggiorna ML prediction - NOTA GLI ID CORRETTI!
        if (data.ml_prediction) {
            const pred = data.ml_prediction;
            const predBox = document.getElementById('aiPrediction');
            const confEl = document.getElementById('confidence');
            
            if (predBox) {
                const direction = (pred.direction || 'NEUTRAL').toUpperCase();
                const cssClass = direction === 'BULLISH' ? 'signal-bullish' : 
                               direction === 'BEARISH' ? 'signal-bearish' : 
                               'signal-neutral';
                predBox.innerHTML = `<span class="signal-box ${cssClass}">${direction}</span>`;
            }
            
            if (confEl) {
                confEl.textContent = Math.round(pred.confidence || 50);
            }
        }
        
        // Aggiorna Technical data
        if (data.technical_analysis?.support_resistance) {
            const tech = data.technical_analysis.support_resistance;
            this.updateElement('current-price', this.formatPrice(tech.current_price));
            this.updateElement('support-level', this.formatPrice(tech.strong_support));
            this.updateElement('resistance-level', this.formatPrice(tech.strong_resistance));
        }
        
        // Aggiorna Quick Analysis
        this.updateQuickAnalysis(data);
        
        // Aggiorna GPT Analysis
        if (data.gpt_analysis) {
            this.updateGPTAnalysis(data.gpt_analysis);
        }
    }
    
    updateQuickAnalysis(data) {
        const box = document.getElementById('quickAnalysis');
        if (!box) return;
        
        const cotData = data.cot_data || data.latest_cot || {};
        const netPos = cotData.net_position || 0;
        const sentiment = cotData.sentiment_score || 0;
        
        let html = '<div class="row g-2">';
        html += `<div class="col-6"><small class="text-muted">Net Position</small><div class="fw-bold">${this.formatNumber(netPos)}</div></div>`;
        html += `<div class="col-6"><small class="text-muted">Sentiment</small><div class="fw-bold">${sentiment.toFixed(2)}%</div></div>`;
        html += `<div class="col-12 mt-2"><small class="text-muted">Interpretazione</small><div>`;
        
        if (sentiment > 20) {
            html += '<span class="badge bg-success">Sentiment Rialzista Forte</span>';
        } else if (sentiment > 10) {
            html += '<span class="badge bg-success">Sentiment Rialzista</span>';
        } else if (sentiment < -20) {
            html += '<span class="badge bg-danger">Sentiment Ribassista Forte</span>';
        } else if (sentiment < -10) {
            html += '<span class="badge bg-danger">Sentiment Ribassista</span>';
        } else {
            html += '<span class="badge bg-secondary">Sentiment Neutrale</span>';
        }
        
        html += '</div></div></div>';
        box.innerHTML = html;
    }
    
    updateMarketOverview(data) {
        const box = document.getElementById('marketOverview');
        if (!box) return;
        
        const sentiment = data.market_sentiment || data.sentiment || 0;
        const risk = data.risk_on ? 'Risk-ON' : data.risk_off ? 'Risk-OFF' : '‚Äî';
        const today = new Date().toLocaleDateString('it-IT');
        
        box.innerHTML = `
            <div class="row g-3">
                <div class="col-md-4">
                    <div class="metric-card">
                        <div class="metric-value">${sentiment}%</div>
                        <div class="metric-label">Market Sentiment</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric-card" style="background:linear-gradient(135deg,#34d399 0%, #10b981 100%)">
                        <div class="metric-value">${risk}</div>
                        <div class="metric-label">Risk Regime</div>
                    </div>
                </div>
                <div class="col-md-4">
                    <div class="metric-card" style="background:linear-gradient(135deg,#f59e0b 0%, #ef4444 100%)">
                        <div class="metric-value">${today}</div>
                        <div class="metric-label">Oggi</div>
                    </div>
                </div>
            </div>`;
    }
    
    updateCOTTable(data) {
        const tbody = document.getElementById('cotDataTable');
        if (!tbody || !Array.isArray(data)) return;
        
        tbody.innerHTML = '';
        
        // Prendi solo i primi 10 record
        data.slice(0, 10).forEach(row => {
            const tr = document.createElement('tr');
            const date = new Date(row.date).toLocaleDateString('it-IT');
            
            tr.innerHTML = `
                <td>${date}</td>
                <td>${this.formatNumber(row.non_commercial_long)}</td>
                <td>${this.formatNumber(row.non_commercial_short)}</td>
                <td>${this.formatNumber(row.commercial_long)}</td>
                <td>${this.formatNumber(row.commercial_short)}</td>
                <td>${this.formatNumber(row.net_position)}</td>
                <td>${(row.sentiment_score || 0).toFixed(2)}%</td>
            `;
            
            tbody.appendChild(tr);
        });
    }
    
    updateElement(id, value) {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = value || 'N/A';
        }
    }
    
    formatNumber(num) {
        if (!num && num !== 0) return 'N/A';
        return new Intl.NumberFormat('it-IT').format(num);
    }
    
    formatPrice(price) {
        if (!price && price !== 0) return 'N/A';
        
        // Formatta in base al valore
        if (price > 1000) {
            return price.toFixed(2);
        } else if (price > 10) {
            return price.toFixed(3);
        } else {
            return price.toFixed(4);
        }
    }
    
    updateSentimentBar(sentiment) {
        const bar = document.getElementById('sentimentBar');
        if (!bar) return;
        
        // Trova o crea la barra interna
        let fillBar = bar.querySelector('div');
        if (!fillBar) {
            fillBar = document.createElement('div');
            bar.appendChild(fillBar);
        }
        
        if (sentiment !== undefined) {
            const w = Math.min(100, Math.max(0, Math.abs(sentiment)));
            fillBar.style.width = `${w}%`;
            fillBar.style.height = '100%';
            fillBar.style.transition = 'width 0.3s';
            
            // Colora in base al valore
            if (sentiment >= 10) {
                fillBar.style.background = 'linear-gradient(90deg,#10b981,#34d399)';
            } else if (sentiment <= -10) {
                fillBar.style.background = 'linear-gradient(90deg,#ef4444,#f87171)';
            } else {
                fillBar.style.background = 'linear-gradient(90deg,#6b7280,#9ca3af)';
            }
        }
    }
    
    updateGPTAnalysis(analysis) {
        const container = document.getElementById('gptAnalysis');
        if (!container) return;
        
        if (typeof analysis === 'string') {
            container.innerHTML = `<div class="p-3 bg-light rounded"><p>${analysis}</p></div>`;
        } else if (analysis && analysis.summary) {
            let html = '<div class="p-3 bg-light rounded">';
            if (analysis.summary) {
                html += `<p>${analysis.summary}</p>`;
            }
            if (analysis.direction) {
                html += `<div class="mt-2"><strong>Direzione:</strong> ${analysis.direction}</div>`;
            }
            if (analysis.confidence) {
                html += `<div><strong>Confidenza:</strong> ${analysis.confidence}%</div>`;
            }
            html += '</div>';
            container.innerHTML = html;
        }
    }
    
    async initializeCharts() {
        // Verifica che Chart.js sia caricato
        if (typeof Chart === 'undefined') {
            console.error('‚ùå Chart.js non trovato!');
            return;
        }
        
        // Distruggi grafici esistenti
        Object.values(this.charts).forEach(chart => {
            if (chart) chart.destroy();
        });
        this.charts = {};
        
        // COT Chart
        const cotCanvas = document.getElementById('cotChart');
        if (cotCanvas) {
            const ctx = cotCanvas.getContext('2d');
            this.charts.cot = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'NC Long',
                            data: [],
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16,185,129,0.1)'
                        },
                        {
                            label: 'NC Short',
                            data: [],
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239,68,68,0.1)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'top' }
                    }
                }
            });
        }
        
        // Pie Chart
        const pieCanvas = document.getElementById('pieChart');
        if (pieCanvas) {
            const ctx = pieCanvas.getContext('2d');
            this.charts.pie = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['NC Long', 'NC Short', 'Commercial Long', 'Commercial Short'],
                    datasets: [{
                        data: [0, 0, 0, 0],
                        backgroundColor: ['#10b981', '#ef4444', '#3b82f6', '#f59e0b']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }
        
        // Price Chart
        const priceCanvas = document.getElementById('priceChart');
        if (priceCanvas) {
            const ctx = priceCanvas.getContext('2d');
            this.charts.price = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Prezzo',
                        data: [],
                        borderColor: '#2563eb',
                        backgroundColor: 'rgba(37,99,235,0.1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }
        
        console.log('‚úÖ Grafici inizializzati');
    }
    
    updateCOTChart(data) {
        if (!this.charts.cot || !data) return;
        
        const labels = [];
        const ncLong = [];
        const ncShort = [];
        
        // Ordina per data e prendi ultimi 30 giorni
        const sortedData = Array.isArray(data) ? 
            data.sort((a, b) => new Date(a.date) - new Date(b.date)).slice(-30) : [];
        
        sortedData.forEach(item => {
            labels.push(new Date(item.date).toLocaleDateString('it-IT'));
            ncLong.push(item.non_commercial_long);
            ncShort.push(item.non_commercial_short);
        });
        
        // Aggiorna COT chart
        this.charts.cot.data.labels = labels;
        this.charts.cot.data.datasets[0].data = ncLong;
        this.charts.cot.data.datasets[1].data = ncShort;
        this.charts.cot.update('none');
        
        // Aggiorna Pie chart con ultimo dato
        if (this.charts.pie && sortedData.length > 0) {
            const last = sortedData[sortedData.length - 1];
            this.charts.pie.data.datasets[0].data = [
                last.non_commercial_long,
                last.non_commercial_short,
                last.commercial_long,
                last.commercial_short
            ];
            this.charts.pie.update('none');
        }
        
        console.log('‚úÖ Grafici COT aggiornati');
    }
    
    updateTechnicalCharts(techData) {
        // Implementazione placeholder
        console.log('üìà Update technical charts:', techData);
    }
    
    updateEconomicIndicators(data) {
        const container = document.getElementById('economicIndicators');
        if (!container) return;
        
        let html = '<div class="row g-3">';
        
        if (data.key_indicators) {
            for (const [key, value] of Object.entries(data.key_indicators)) {
                const val = value.value || value;
                html += `
                    <div class="col-md-4">
                        <div class="p-3 border rounded">
                            <div class="text-muted small">${key.replace(/_/g, ' ')}</div>
                            <div class="h5 mb-0">${val}</div>
                        </div>
                    </div>`;
            }
        }
        
        html += '</div>';
        container.innerHTML = html;
    }
    
    // Metodi aggiuntivi per le altre tab
    async loadTechnicalData() {
        console.log('üìä Caricamento dati tecnici...');
        // Implementazione futura
    }
    
    async loadEconomicData() {
        console.log('üí∞ Caricamento dati economici...');
        // Implementazione futura
    }
    
    async loadPredictionsData() {
        console.log('üîÆ Caricamento previsioni...');
        // Implementazione futura
    }
    
    async runFullAnalysis() {
        console.log('üß† Avvio analisi AI completa...');
        
        try {
            const response = await fetch(`/api/scrape/${this.currentSymbol}`, {
                method: 'POST'
            });
            
            if (response.ok) {
                const data = await response.json();
                console.log('‚úÖ Analisi completata:', data);
                
                // Ricarica dati
                await this.loadInitialData();
            }
        } catch (error) {
            console.error('‚ùå Errore analisi:', error);
        }
    }
    
    async switchSymbol(symbol) {
        if (symbol === this.currentSymbol || this.isLoading) return;
        
        // Debounce
        clearTimeout(this.debounceTimer);
        this.debounceTimer = setTimeout(async () => {
            console.log(`üîÑ Cambio simbolo: ${this.currentSymbol} -> ${symbol}`);
            this.currentSymbol = symbol;
            
            // Aggiorna UI
            document.querySelectorAll('.symbol-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.symbol === symbol);
            });
            
            // Ricarica dati
            await this.loadInitialData();
            
        }, this.debounceDelay);
    }
    
    async forceRefresh() {
        console.log('üîÑ Force refresh...');
        this.cache.clear();
        await this.loadInitialData();
    }
    
    startAutoRefresh(interval = 30000) {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
        
        this.updateInterval = setInterval(() => {
            if (!this.isLoading) {
                console.log('üîÑ Auto-refresh...');
                this.loadInitialData();
            }
        }, interval);
        
        console.log(`‚è∞ Auto-refresh attivo ogni ${interval/1000}s`);
    }
    
    stopAutoRefresh() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }
    
    showLoader() {
        // Implementazione semplificata
        document.querySelectorAll('.loading').forEach(el => {
            el.style.display = 'block';
        });
    }
    
    hideLoader() {
        document.querySelectorAll('.loading').forEach(el => {
            el.style.display = 'none';
        });
    }
    
    showError(message) {
        console.error('‚ùå', message);
        // Potresti aggiungere un toast o alert
    }
    
    destroy() {
        this.stopAutoRefresh();
        
        Object.values(this.charts).forEach(chart => {
            if (chart) chart.destroy();
        });
        
        this.cache.clear();
        console.log('üîö Dashboard distrutta');
    }
}

// Inizializza quando DOM √® pronto
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM Ready - Inizializzazione COT Dashboard');
        window.cotDashboard = new COTDashboard();
    });
} else {
    // DOM gi√† caricato
    console.log('Inizializzazione immediata COT Dashboard');
    window.cotDashboard = new COTDashboard();
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (window.cotDashboard) {
        window.cotDashboard.destroy();
    }
});